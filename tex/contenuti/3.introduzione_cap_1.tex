
\chapter{Introduzione}


\section{TCP/IP e modello a strati \ok}


\begin{comment}
https://en.wikipedia.org/wiki/Internet_protocol_suite
https://it.wikipedia.org/wiki/Modello_OSI
https://datatracker.ietf.org/doc/html/rfc1122
https://datatracker.ietf.org/doc/html/rfc791
https://datatracker.ietf.org/doc/html/rfc791#section-2.1
https://datatracker.ietf.org/doc/html/rfc791#section-2.2

\cite https://datatracker.ietf.org/doc/html/rfc1122#section-1

An Internet communication system consists of interconnected packet networks supporting communication among host computers using the Internet protocols.  The networks are interconnected using packet-switching computers called "gateways" or "IP routers" by the Internet community, and "Intermediate Systems" by the OSI world [INTRO:13].

After looking at the major milestones in the history of the Internet, let's take a closer look into the current architectural design of the Internet.

Connecting hosts running the same applications but located in different types of networks. A computer network is a complex system that is built on top of multiple components. These components can vary in technologies making up different types of networks that offer different types of applications. For example in the figure below, we have two BitTorrent clients that communicate even though they are using very different networks/technologies (Wifi vs Ethernet). So, how do these technologies and components interconnect and come together to meet the needs of each application? The designers of the network protocols provide structure to the network architecture by organizing the protocols into layers.
\end{comment}


% ok
Internet costituisce la più grande rete di comunicazione al mondo, con più di 5 miliardi di dispositivi connessi nello stesso momento \cite{owidinternet}. Eppure la sua architettura di base è relativamente semplice, tutto è incentrato su un set di protocolli e i dispositivi che li implementano.

\begin{comment}
Un sistema di comunicazione Internet consiste in un interconnessione tra reti di pacchetti, che supportano la comunicazione tra hosts usando una suite di protocolli.

L'obbiettivo di Internet è quello di collegare hosts attraverso una rete geografica, indipendentemente dalla distanza o da quali mezzi fisici vengano usati per trasferire i dati. Deve quindi essere in grado di gestire una grande varietà di applicazioni, tipi di rete e mezzi di trasmissione. Per garantire la flessibilità necessaria e non aggiungere troppa complessità, l'architettura di Internet è sta suddivisa in alcuni strati.
\end{comment}

Il suo obbiettivo è quello di collegare utenti attraverso una rete geografica, indipendentemente dalla distanza o da quali mezzi fisici vengano usati per trasferire i dati. Deve quindi essere in grado di gestire una grande varietà di applicazioni, tipi di rete e mezzi di trasmissione. Per garantire la flessibilità necessaria e non aggiungere troppa complessità, l'architettura di Internet è sta suddivisa in alcuni strati, il modello TCP/IP è costituito da 4 strati. 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{immagini/diag2-modello_a_strati}
    \caption{Rappresentazione degli strati del modello TCP/Ip, con relativo incapsulamento e dispositivo di dominio}
    \label{fig:modello-a-strati}
\end{figure}

\newpage
\subsection{Internet Protocol Suite \ok}

\begin{comment}
Internet Protocol Suit
To communicate using the Internet system, a host must implement
the layered set of protocols comprising the Internet protocol
suite.  A host typically must implement at least one protocol
from each layer.
\end{comment}

% ok
Per comunicare su Internet, gli Host devono implementare un set di protocolli che costituiscono l'\textit{Internet protocol suite} \cite{RFC_1122}. I protocolli si suddividono in strati logici che li raggruppano in 4 categorie, ogni Host deve implementare almeno un protocollo per ogni strato.



% TODO forse espandere (?)
Vediamo una breve descrizione dei layer e delle loro funzioni:

\begin{enumerate} % \cite https://datatracker.ietf.org/doc/html/rfc1122#section-1
    \item[layer 4:] \textbf{Application}: Il livello applicazione è il layer pi\`u alto dell'\textit{Internet protocol suite}, i protocolli di questo livello si suddividono in protocolli utente e di supporto. \newline
        I protocolli utente espongono un servizio direttamente all'utente finale, alcuni esempi sono: \href{https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol}{http}, \href{https://en.wikipedia.org/wiki/File_Transfer_Protocol}{ftp}, \href{https://en.wikipedia.org/wiki/Secure_Shell}{ssh}. Mentre i protocolli di supporto non sono direttamente usati dagli utenti ma sono comunque necessari per il funzionamento della rete, alcuni esempi sono: \href{https://en.wikipedia.org/wiki/Domain_Name_System}{DNS}, \href{https://en.wikipedia.org/wiki/Simple_Network_Management_Protocol}{SNMP}.

        \begin{comment}
        The application layer is the top layer of the Internet
        protocol suite.  The Internet suite does not further
        subdivide the application layer, although some of the
        Internet application layer protocols do contain some
        internal sub-layering.  The application layer of the
        Internet suite essentially combines the functions of the
        top two layers -- Presentation and Application -- of the
        OSI reference model.

        We distinguish two categories of application layer
        protocols:  user protocols that provide service directly
        to users, and support protocols that provide common system
        functions.  Requirements for user and support protocols
        will be found in the companion RFC [INTRO:1].

        The most common Internet user protocols are:

        o  Telnet (remote login)
        o  FTP    (file transfer)
        o  SMTP   (electronic mail delivery)

        There are a number of other standardized user protocols
            [INTRO:4] and many private user protocols.

        Support protocols, used for host name mapping, booting,
        and management, include SNMP, BOOTP, RARP, and the Domain
        Name System (DNS) protocols.
        \end{comment}

    \item[layer 3:] \textbf{Transport}: Il livello di trasporto fornisce una comunicazione end-to-end tra per le applicazioni, infatti in generale il campo data del livello di trasporto non viene letto da nessuno se non l'applicazione di sorgente e destinazione. I protocolli principali di questo livello sono TCP e UDP: il \href{https://en.wikipedia.org/wiki/Transmission_Control_Protocol}{TCP} è connection-oriented e fornisce alta affidabilità; mentre l'\href{https://en.wikipedia.org/wiki/User_Datagram_Protocol}{UDP} è connection-less, quindi ogni inaffidabilità della rete deve essere gestita a livello applicazione.

        \begin{comment}
        The transport layer provides end-to-end communication
        services for applications.  There are two primary
        transport layer protocols at present:

        o Transmission Control Protocol (TCP)
        o User Datagram Protocol (UDP)

        TCP is a reliable connection-oriented transport service
        that provides end-to-end reliability, resequencing, and
        flow control.  UDP is a connectionless ("datagram")
        transport service.

        Other transport protocols have been developed by the
        research community, and the set of official Internet
        transport protocols may be expanded in the future.

        Transport layer protocols are discussed in Chapter 4.
        \end{comment}

        % TODO da rivedere (?)
    \item[layer 2:] \textbf{Internet}: Tutti i protocolli di trasporto usano il protocollo Internet (IP) per portare i dati dall'host sorgente alla destinazione. Al contrario dei protocolli di livello trasporto il protocollo IP non è end-to-end, quindi è intrinsecamente di tipo connection-less. Non fornisce quindi nessuna garanzia che il pacchetto arrivi a destinazione, o arrivi danneggiato o duplicato. I layer sopra al livello IP sono responsabili di mantenere l'affidabilità dei servizi quando essa è richiesta. Di questo layer fanno parte i protocolli \href{https://en.wikipedia.org/wiki/Internet_Protocol}{IP} e \href{https://en.wikipedia.org/wiki/Internet_Control_Message_Protocol}{ICMP} ad esempio.

        \begin{comment}
        All Internet transport protocols use the Internet Protocol
        (IP) to carry data from source host to destination host.
        IP is a connectionless or datagram internetwork service,
        providing no end-to-end delivery guarantees. Thus, IP
        datagrams may arrive at the destination host damaged,
        duplicated, out of order, or not at all.  The layers above
        IP are responsible for reliable delivery service when it
        is required.  The IP protocol includes provision for
        addressing, type-of-service specification, fragmentation
        and reassembly, and security information.

        The datagram or connectionless nature of the IP protocol
        is a fundamental and characteristic feature of the
        Internet architecture.  Internet IP was the model for the
        OSI Connectionless Network Protocol [INTRO:12].

        ICMP is a control protocol that is considered to be an
        integral part of IP, although it is architecturally
        layered upon IP, i.e., it uses IP to carry its data end-
        to-end just as a transport protocol like TCP or UDP does.
        ICMP provides error reporting, congestion reporting, and
        first-hop gateway redirection.

        IGMP is an Internet layer protocol used for establishing
        dynamic host groups for IP multicasting.

        The Internet layer protocols IP, ICMP, and IGMP are
        discussed in Chapter 3.
        \end{comment}

        
    \item[layer 1:] \textbf{Link}: È il layer più vicino al mezzo fisico su cui viaggiano i dati, ogni host deve implementare il protocollo usato per la specifica interfaccia che usa. Ad esempio un'host con un'interfaccia Ethernet deve implementare i protocolli \href{https://en.wikipedia.org/wiki/Ethernet_frame#Ethernet_II}{Ethernet II} e \href{https://en.wikipedia.org/wiki/IEEE_802.3}{IEEE 802.3}.

        \begin{comment}
        To communicate on its directly-connected network, a host
        must implement the communication protocol used to
        interface to that network.  We call this a link layer or
        media-access layer protocol.

        There is a wide variety of link layer protocols,
        corresponding to the many different types of networks.
        See Chapter 2.
        \end{comment}

\end{enumerate}

\newpage
\subsection{Incapsulamento \ok}

Ogni protocollo di ogni layer aggiunge un header e un trailer, incapsulando il prodotto del layer precedente nel suo campo data, possiamo vederne una rappresentazione grafica in fig. \ref{fig:modello-a-strati}.

Possiamo inoltre esaminare l'incapsulamento in azione catturando un pacchetto con il programma \textit{Wireshark}, ad esempio in questo caso si tratta di un pacchetto proveniente da una pagina web \textit{https}:

\begin{bashcode}{Wireshark}{tls-wireshark}
Frame 43408: 93 bytes on wire (744 bits), 93 bytes captured (744 bits) on interface wlp5s0, id 0
1 > Ethernet II, Src: IntelCor_eb:91:5f (cc:d9:ac:eb:91:5f), Dst: HuaweiDe_27:a9:24 (0c:e4:a0:27:a9:24)
2 > Internet Protocol Version 4, Src: 192.168.8.119, Dst: 142.250.180.174
3 > Transmission Control Protocol, Src Port: 36354, Dst Port: 443, Seq: 36720, Ack: 13639, Len: 39
4 > Transport Layer Security
> TLSv1.3 Record Layer: Application Data Protocol: http-over-tls
Opaque Type: Application Data (23)
Version: TLS 1.2 (0x0303)
Length: 34
Encrypted Application Data: 389bf9516cce567d0d90ef62ba2a87376091fedb7f66f3b9e60e45a39376b1ae667a
    [Application Data Protocol: http-over-tls]
\end{bashcode}

Quindi andando ad analizzare lo stack di protocolli si vede:

\begin{itemize}
    \item \textbf{Transport Layer Security}\cite{RFC_8446}: È il dato effettivo che è stato trasmesso in rete. In questo caso consiste in un pacchetto http cifrato con il protocollo TLS.

    \item \textbf{Transmission Control Protocol}\cite{RFC_0793}: Incapsula il layer applicazione in un layer di trasporto usando il protocollo TCP. Le informazioni principali contenute nell'header sono la porta sorgente e destinazione, ciò permette di individuare a quale applicazione è destinato il pacchetto.
    
    \item \textbf{Internet Protocol Version 4}\cite{RFC_0791}: Incapsula il layer di trasporto in un pacchetto IP. Nell'header IP sono contenuti l'indirizzo IP di sorgente e destinazione, ciò permette di individuare a quale host è destinato il pacchetto.
    
    \item \textbf{Ethernet II}\cite{ethernet-ii}: In questo caso il mezzo fisico è una porta Ethernet, quindi il pacchetto IP viene incapsulato con il protocollo Ethernet II. Nell'header Ethernet II sono contenuti l'indirizzo MAC di sorgente e destinazione, ciò permette di individuare qual è l'interfaccia fisica a cui è destinato il pacchetto.
\end{itemize}

\newpage
Possiamo vedere graficamente il pacchetto descritto in code:\ref{code:tls-wireshark} e le informazioni principali di ogni header:

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{immagini/diag2-incapsulamento}
    \caption{Incapsulamento}
    \label{fig:incapsulamento}
\end{figure}


\subsection{IP Network Address Translator (NAT) \ok}

\begin{comment}
https://datatracker.ietf.org/doc/html/rfc2663
https://en.wikipedia.org/wiki/Network_address_translation
    \cite{https://en.wikipedia.org/wiki/IPv4_address_exhaustion}
https://www.rfc-editor.org/rfc/rfc4787 ?? 
https://datatracker.ietf.org/doc/html/rfc1631
\end{comment}

\begin{comment}
It has become a popular and essential tool in conserving global address space in the face of IPv4 address exhaustion. 

The two most compelling problems facing the IP Internet are IP address depletion and scaling in routing.
\end{comment}

% ok
Per mitigare il problema della saturazione degli indirizzi IPv4 \cite{ipv4_exhaustion}, è stato introdotto un dispositivo di rete che consente di riusare spazi di indirizzi privati e ridurre il numero di Ipv4 pubblici necessari. 

\begin{comment}
Network address translation (NAT) is a method of mapping an IP address space into another by modifying network address information in the IP header of packets while they are in transit across a traffic routing device. One Internet-routable IP address of a NAT gateway can be used for an entire private network.

The main advantage of NAT is that it can be installed without changes to routers or hosts. This solution has the disadvantage of taking away the end-to-end significance of an IP address, and making up for it with increased state in the network.
\end{comment}

% ok
Il NAT \cite{RFC_1631} permette di effettuare una mappatura da uno spazio di indirizzi a un altro, modificando così le informazioni di routing nel pacchetto IP. La mappatura può essere sia \mbox{uno-a-uno}, nel caso di \textit{Static NAT} e \textit{Dynamic NAT}; sia molti-a-molti, nel caso di \textit{Network Address and Port Translation} (NAPT), in cui oltre all'IP viene modificata anche la porta del protocollo di trasporto. Ciò consente di mappare un grande numero di indirizzi privati in relativamente pochi indirizzi pubblici. 

\begin{comment}
The address reuse solution is to
place Network Address Translators (NAT) at the borders of stub
domains. Each NAT box has a table consisting of pairs of local IP
addresses and globally unique addresses. The IP addresses inside the
stub domain are not globally unique. They are reused in other
domains, thus solving the address depletion problem. The globally
unique IP addresses are assigned according to current CIDR address
allocation schemes.
\end{comment}

\begin{comment}
Una delle applicazioni più comuni è inserirlo nel gateway di una rete privata domestica, ciò permette di mascherare i dispositivi nella rete privata e far si che la rete esterna veda tutto il traffico attraverso un solo dispositivo, il router.
\end{comment}


\begin{comment}
svantaggi del nat
    - il nat rompe la comunicazione end to end
    - a meno che non si modifichi la configurazione del nat non è possibile fare una comunicazione end to end
    - cita nat hole qualcosa
\end{comment}

Dato il funzionamento del NAT è intrinsecamente impossibile comunicare dall'esterno verso un dispositivo al di sotto del NAT a meno che non venga opportunamente configurato per consentirlo.


Prendiamo in esempio un NAT di tipo \textit{easyip}, in questo caso un'intera sottorete viene mappata su un singolo IP esterno. Ogni volta che un'host della rete tenta di comunicare con un server esterno, nel NAT viene salvata la relazione tra chi ha inviato la richiesta e su quale porta esterna è stata inviata verso il server. Data questa relazione il NAT è in grado di re-inoltrare all'host corretto la risposta del server. Si vede quindi che la comunicazione attraverso un NAT è possibile solo se viene iniziata da un'host della rete privata, poiché in caso contrario il NAT non potrebbe conoscere a quale host stiamo tentando di comunicare e quindi semplicemente scarterebbe il pacchetto.


\subsubsection{Carrier Grade NAT (CG-NAT) \ok}
\label{subsubsec:cg-nat}

\begin{comment}
https://en.wikipedia.org/wiki/Carrier-grade_NAT
    Carrier-grade NAT (CGN or CGNAT), also known as large-scale NAT (LSN), is a type of Network address translation (NAT) for use in IPv4 network design. With CGNAT, end sites, in particular residential networks, are configured with private network addresses that are translated to public IPv4 addresses by middlebox network address translator devices embedded in the network operator's network, permitting the sharing of small pools of public addresses among many end sites. This shifts the NAT function and configuration thereof from the customer premises to the Internet service provider network (though "conventional" NAT on the customer premises will often be used additionally).

    Carrier-grade NAT is often used for mitigating IPv4 address exhaustion.
\end{comment}

I CG-NAT \cite{Carrier-grade_NAT} sono una tipologia di NAT che lavorano su larga scala e in generale sono implementati all'interno della rete dell'ISP. Sono usati per mappare un grande numero di utenti in relativi pochi indirizzi pubblici.
Dato che sono gestiti dall'ISP, gli utenti non hanno nessun controllo sulla sua configurazione.


\section{Openvpn \ok}

\begin{comment}
https://wiki.wireshark.org/OpenVPN
https://build.openvpn.net/doxygen/network_protocol.html

OpenVPN [OpenVPN] is a commonly used protocol designed as an
alternative to IPsec.  A major goal of this protocol is to provide a
VPN that is simple to configure and works over a variety of
transports.  OpenVPN encapsulates either IP packets or Ethernet
frames within a secure tunnel and can run over either UDP or TCP.
For key establishment, OpenVPN can either use TLS as a handshake
protocol or use pre-shared keys.

OpenVPN is a virtual private network (VPN) system that implements techniques to create secure point-to-point or site-to-site connections in routed or bridged configurations and remote access facilities. It implements both client and server applications.

OpenVPN allows peers to authenticate each other using pre-shared secret keys, certificates or username/password. When used in a multiclient-server configuration, it allows the server to release an authentication certificate for every client, using signatures and certificate authority.

It uses the OpenSSL encryption library extensively, as well as the TLS protocol, and contains many security and control features. It uses a custom security protocol[11] that utilizes SSL/TLS for key exchange. It is capable of traversing network address translators (NATs) and firewalls.

OpenVPN has been ported and embedded to several systems. For example, DD-WRT has the OpenVPN server function. SoftEther VPN, a multi-protocol VPN server, also has an implementation of OpenVPN protocol.

It was written by James Yonan and is free software, released under the terms of the GNU General Public License version 2 (GPLv2).[12] Additionally, commercial licenses are available.[13]
\end{comment}

OpenVPN è un applicativo open source che ha l'obbiettivo di fornire una VPN che sia semplice da configurare e che funzioni in ogni contesto. Openvpn può incapsulare sia pacchetti IP che frame Ethernet, in un tunnel sicuro che può viaggiare sia su TCP che UDP. Ha molte opzioni di configurazione, come la possibilità di usare qualsiasi porta, oppure l'uso della compressione. Il tutto è raccolto in un singolo applicativo che può funzionare sia da client che da server, in base alla configurazione fornita.

Possiamo ad esempio vedere una cattura di Wireshark di un pacchetto OpenVPN su UDP e porta 1194:

\begin{bashcode}{Wireshark}{openvpn-wireshark}
> Frame 90: 82 bytes on wire (656 bits), 82 bytes captured (656 bits) on interface br-08876ccdf1f5, id 0
> Ethernet II, Src: cc:d9:ac:eb:91:5f (cc:d9:ac:eb:91:5f), Dst: 0c:e4:a0:27:a9:24 (0c:e4:a0:27:a9:24)
> Internet Protocol Version 4, Src: 192.168.1.20, Dst: 51.178.141.119
> User Datagram Protocol, Src Port: 47007, Dst Port: 1194
> OpenVPN Protocol
Type: 0x48 [opcode/key_id]
Peer ID: 0
Data (36 bytes)
Data: 00000019a366196eb2aca181df226faf8514ab73f524f7ef335d55fc57322d032a2095e4
\end{bashcode}

\subsection{Crittografia e autenticazione \ok}
\label{subsec:auth}

\begin{comment}
https://community.openvpn.net/openvpn/wiki/How_does_PKI_work
https://it.wikipedia.org/wiki/Infrastruttura_a_chiave_pubblica
https://en.wikipedia.org/wiki/Public_key_infrastructure

OpenVPN uses the OpenSSL library to provide encryption of both the data and control channels. It lets OpenSSL do all the encryption and authentication work, allowing OpenVPN to use all the ciphers available in the OpenSSL package. It can also use the HMAC packet authentication feature to add an additional layer of security to the connection (referred to as an "HMAC Firewall" by the creator). It can also use hardware acceleration to get better encryption performance.[14][15] Support for mbed TLS is available starting from version 2.3.[16]
\href{https://en.wikipedia.org/wiki/OpenSSL}{OpenSSL}
\end{comment}

% ok
Per la cifratura e autenticazione viene usata la libreria \href{https://en.wikipedia.org/wiki/OpenSSL}{OpenSSL}, open source e ampiamente usata dalla maggior parte dei servizi su internet, come ad esempio l'https. Ciò fornisce ad OpenVPN la flessibilità di poter usare tutti i cifrari forniti da questa libreria.

\begin{comment}
OpenVPN has several ways to authenticate peers with each other. OpenVPN offers pre-shared keys, certificate-based, and username/password-based authentication. Preshared secret key is the easiest, and certificate-based is the most robust and feature-rich. In version 2.0 username/password authentications can be enabled, both with or without certificates. However, to make use of username/password authentications, OpenVPN depends on third-party modules.
\end{comment}

% ok
L'autenticazione può essere eseguita usando una pre-shared key, un sistema basato sull'utilizzo dei certificati, una semplice password o una combinazione dei precedenti. Il metodo più sicuro è quello basato sui certificati, che sfrutta una \textit{Public key infrastructure} \cite{pki} per autenticare che i certificati forniti dai client siano effettivamente autentici. Con questo metodo si crea un certificato per ogni utente che, se opportunamente firmato, permette allo specifico utente di autenticarsi al server VPN. Questo metodo ha inoltre il vantaggio che un certificato può essere revocato in ogni momento \cite{revoke-cert}, facendo così perdere l'accesso all'utente che lo stava usando. 

% ok
Maggiori informazioni possono essere trovate sulla \href{https://community.openvpn.net/openvpn/wiki/How_does_PKI_work}{wiki di OpenVPN}.

\subsection{Networking}
\label{subsec:openvpn-networking}

\begin{comment}
OpenVPN can run over User Datagram Protocol (UDP) or Transmission Control Protocol (TCP) transports, multiplexing created SSL tunnels on a single TCP/UDP port[17] (RFC 3948 for UDP).[18]

It has the ability to work through most proxy servers (including HTTP) and is good at working through network address translation (NAT) and getting out through firewalls.  

OpenVPN's use of common network protocols (TCP and UDP) makes it a desirable alternative to IPsec in situations where an ISP may block specific VPN protocols.
\end{comment}

% ok
OpenVPN viene incapsulato dai più comuni protocolli di trasporto (TCP e UDP), ciò lo rende adatto in caso l'ISP blocchi VPN di livello più basso, es. \href{https://en.wikipedia.org/wiki/IPsec}{ipsec}. Può inoltre funzionare attraverso la maggior parte dei server proxy, firewall e NAT.

\begin{comment}
The server configuration has the ability to "push" certain network configuration options to the clients. These include IP addresses, routing commands, and a few connection options.

OpenVPN offers two types of interfaces for networking via the Universal TUN/TAP driver. It can create either a layer-3 based IP tunnel (TUN), or a layer-2 based Ethernet TAP that can carry any type of Ethernet traffic. OpenVPN can optionally use the LZO compression library to compress the data stream. Port 1194 is the official IANA assigned port number for OpenVPN. Newer versions of the program now default to that port. A feature in the 2.0 version allows for one process to manage several simultaneous tunnels, as opposed to the original "one tunnel per process" restriction on the 1.x series.
\end{comment}


La configurazione del server permette di impostare opzioni che modificano la configurazione di rete del server o dei client, ciò permette ad esempio di aggiungere una rotta alla tabella di routing dei client nel momento in cui si connettono alla VPN.


Per depositare il traffico nella network stack dei client, OpenVPN usa i \href{https://docs.kernel.org/networking/tuntap.html}{driver universali \\TUN/TAP}. Può quindi creare sia un tunnel IP di livello 3 (TUN), sia Ethernet livello 2 (TAP).


\begin{comment}
il tunnel si realizza come si vede in figura

il pacchetto interno è cifrato e incapsulato in quello esterno

quello interno ha IP relativi alla subnet della VPN

quello esterno ha gli IP delgli hosts

il pacchetto interno può essere decifrato solo da host della VPN
\end{comment}

In figura \ref{fig:incapsulamento-openvpn} possiamo vedere l'incapsulamento del pacchetto OpenVPN descritto in code:~\ref{code:openvpn-wireshark}, compreso di un esempio del contenuto cifrato. 

Si può vedere come il protocollo OpenVPN contenga al suo interno un pacchetto IP/Ethernet cifrato, in questo caso un pacchetto ICMP.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{immagini/diag2-incapsulamento_openvpn}
    \caption{Incapsulamento di un pacchetto OpenVPN.}
    \label{fig:incapsulamento-openvpn}
\end{figure}

Analizzando l'incapsulamento si vede che sono presenti 2 header IP:
\begin{enumerate}
    \item[\bf{Interno}.] Solo gli Host della VPN possono decifrare il pacchetto e leggere questo header. Gli IP di sorgente/destinazione sono relativi alla subnet della VPN.
    \item[\bf{Esterno}.] Serve a trasportare il pacchetto tra i vari Host della VPN, deve quindi avere IP di sorgente/destinazione indirizzabili in Internet.
\end{enumerate}

\begin{comment}
\begin{bashcode}
Frame 1: 84 bytes on wire (672 bits), 84 bytes captured (672 bits) on interface tun0, id 0
Raw packet data
Internet Protocol Version 4, Src: 10.8.0.2, Dst: 10.8.0.1
Internet Control Message Protocol
    Type: 8 (Echo (ping) request)
    Code: 0
    Checksum: 0xb1f5 [correct]
    [Checksum Status: Good]
    Identifier (BE): 3 (0x0003)
    Identifier (LE): 768 (0x0300)
    Sequence Number (BE): 608 (0x0260)
    Sequence Number (LE): 24578 (0x6002)
    [Response frame: 2]
    Timestamp from icmp data: Jun  6, 2022 18:08:46.000000000 CEST
    [Timestamp from icmp data (relative): 0.871410467 seconds]
    Data (48 bytes)


Frame 1: 84 bytes on wire (672 bits), 84 bytes captured (672 bits) on interface tun0, id 0
Raw packet data
Internet Protocol Version 4, Src: 10.8.0.2, Dst: 10.8.0.1
Internet Control Message Protocol

\end{bashcode}
\end{comment}


\section{OpenWrt \ok}

\begin{bashcode}{Login banner di Openwrt}{}
BusyBox v1.35.0 (2022-04-24 21:09:51 UTC) built-in shell (ash)
_______                     ________        __
|       |.-----.-----.-----.|  |  |  |.----.|  |_
|   -   ||  _  |  -__|     ||  |  |  ||   _||   _|
|_______||   __|_____|__|__||________||__|  |____|
|__| W I R E L E S S   F R E E D O M
-----------------------------------------------------
OpenWrt SNAPSHOT, r19521-46980294f6
-----------------------------------------------------
\end{bashcode}

\begin{comment}
OpenWrt is a highly extensible GNU/Linux distribution for embedded devices (typically wireless routers). Unlike many other distributions for routers, OpenWrt is built from the ground up to be a full-featured, easily modifiable operating system for embedded devices. In practice, this means that you can have all the features you need with none of the bloat, powered by a modern Linux kernel. 
\end{comment}

% ok
OpenWRT è un sistema operativo open-source per sistemi embedded, principalmente usato come firmware alternativo per router domestici. Si basa su kernel linux, con specifica attenzione all'ottimizzazione per renderlo adatto a dispositivi con risorse estremamente limitate.

% ok
Al contrario di altri sistemi operativi per dispositivi embedded, OpenWRT presenta un filesystem con permessi di scrittura. Questo permette di modificare il funzionamento del sistema senza dover reinstallare l'intero firmware a ogni modifica. Per facilitare l'installazione delle funzionalità aggiuntive ha il suo gestore pacchetti (\href{https://openwrt.org/docs/guide-user/additional-software/opkg}{opkg}), ciò lo rende estremamente estensibile e configurabile.

% TODO espandere !
OpenWRT può essere configurato sia tramite shell (\href{https://en.wikipedia.org/wiki/Almquist_shell}{ash}) che tramite interfaccia web (\href{https://openwrt.org/docs/guide-user/luci/start}{LuCI}).


\subsection{LuCI web interface \ok}
\label{subsec:luci-web-interface}

\begin{comment}
The initial reason for this project was the absence of a free, clean, extensible and easily maintainable web user interface for embedded devices. While most similar configuration interfaces make heavy use of the shell-scripting language, LuCI uses the Lua programming language and splits up the interface into logical parts like models and views, uses object-oriented libraries and templating. That ensures a higher performance, smaller installation size, faster runtimes and what is even more important: better maintainability.

Meanwhile LuCI evolved from an MVC-Webframework to a collection of several libraries, applications and user interfaces with general purpose for Lua programmers while the focus still remains on the web user interface which also became an official part of OpenWrt Kamikaze. 
\end{comment}

% ok
LuCI è l'interfaccia web ufficiale di \textit{OpenWrt}, è un progetto open-source nato dalla necessità di un'interfaccia web per sistemi embedded che sia gratuita, completa ed estensibile. L'installazione e configurazione di LuCI è molto semplice, si può infatti seguire la \href{https://openwrt.org/docs/guide-user/luci/luci.essentials}{guida ufficiale}.


\begin{figure}[H]
    \centering

    \begin{subfigure}{1\linewidth}
        \centering
        \includegraphics[height=0.65\linewidth]{immagini/LuCI_status}
        \caption{Status page}
        \label{fig:luci-status}
    \end{subfigure}%

    \medskip

    \begin{subfigure}{0.5\linewidth}
        \centering
        \includegraphics[height=0.65\linewidth]{immagini/LuCI_graphs}
        \caption{Graphs page}
        \label{fig:luci-graphs}
    \end{subfigure}%
    \hfill
    \begin{subfigure}{0.5\linewidth}
        \centering
        \includegraphics[height=0.65\linewidth]{immagini/LuCI_interfaces}
        \caption{Interfaces page}
        \label{fig:luci-interfaces}
    \end{subfigure}%
    \caption{Interfaccia web LuCI}
\end{figure}


L'home page, fig. \ref{fig:luci-status}, mostra un riepilogo dello stato del router, ad esempio sono presenti: informazioni sull'hardware, informazioni sulla memoria e storage, sono presenti inoltre informazioni riassuntive sulle interfacce di rete e sul \textit{DHCP}. L'interfaccia LuCI è estensiva e permette di configurare quasi ogni aspetto del funzionamento del router, compreso il firewall, il \textit{DHCP}, i processi in esecuzione, etc. Presenta inoltre la possibilità di installare plugins che modificano e/o aggiungono funzionalità non presenti di default nell'interfaccia.

